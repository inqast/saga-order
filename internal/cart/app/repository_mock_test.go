package app

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/inqast/saga-order/internal/cart/app.Repository -o ./repository_mock_test.go -n RepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/inqast/saga-order/internal/models"
)

// RepositoryMock implements Repository
type RepositoryMock struct {
	t minimock.Tester

	funcCreateCartItem          func(ctx context.Context, cp1 *models.CartItem) (err error)
	inspectFuncCreateCartItem   func(ctx context.Context, cp1 *models.CartItem)
	afterCreateCartItemCounter  uint64
	beforeCreateCartItemCounter uint64
	CreateCartItemMock          mRepositoryMockCreateCartItem

	funcDeleteCartItem          func(ctx context.Context, i1 int, i2 int) (err error)
	inspectFuncDeleteCartItem   func(ctx context.Context, i1 int, i2 int)
	afterDeleteCartItemCounter  uint64
	beforeDeleteCartItemCounter uint64
	DeleteCartItemMock          mRepositoryMockDeleteCartItem

	funcGetCartItemsByUserId          func(ctx context.Context, i1 int) (cpa1 []*models.CartItem, err error)
	inspectFuncGetCartItemsByUserId   func(ctx context.Context, i1 int)
	afterGetCartItemsByUserIdCounter  uint64
	beforeGetCartItemsByUserIdCounter uint64
	GetCartItemsByUserIdMock          mRepositoryMockGetCartItemsByUserId

	funcReadCartItem          func(ctx context.Context, i1 int, i2 int) (cp1 *models.CartItem, err error)
	inspectFuncReadCartItem   func(ctx context.Context, i1 int, i2 int)
	afterReadCartItemCounter  uint64
	beforeReadCartItemCounter uint64
	ReadCartItemMock          mRepositoryMockReadCartItem

	funcUpdateCartItem          func(ctx context.Context, cp1 *models.CartItem) (err error)
	inspectFuncUpdateCartItem   func(ctx context.Context, cp1 *models.CartItem)
	afterUpdateCartItemCounter  uint64
	beforeUpdateCartItemCounter uint64
	UpdateCartItemMock          mRepositoryMockUpdateCartItem
}

// NewRepositoryMock returns a mock for Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateCartItemMock = mRepositoryMockCreateCartItem{mock: m}
	m.CreateCartItemMock.callArgs = []*RepositoryMockCreateCartItemParams{}

	m.DeleteCartItemMock = mRepositoryMockDeleteCartItem{mock: m}
	m.DeleteCartItemMock.callArgs = []*RepositoryMockDeleteCartItemParams{}

	m.GetCartItemsByUserIdMock = mRepositoryMockGetCartItemsByUserId{mock: m}
	m.GetCartItemsByUserIdMock.callArgs = []*RepositoryMockGetCartItemsByUserIdParams{}

	m.ReadCartItemMock = mRepositoryMockReadCartItem{mock: m}
	m.ReadCartItemMock.callArgs = []*RepositoryMockReadCartItemParams{}

	m.UpdateCartItemMock = mRepositoryMockUpdateCartItem{mock: m}
	m.UpdateCartItemMock.callArgs = []*RepositoryMockUpdateCartItemParams{}

	return m
}

type mRepositoryMockCreateCartItem struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateCartItemExpectation
	expectations       []*RepositoryMockCreateCartItemExpectation

	callArgs []*RepositoryMockCreateCartItemParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateCartItemExpectation specifies expectation struct of the Repository.CreateCartItem
type RepositoryMockCreateCartItemExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateCartItemParams
	results *RepositoryMockCreateCartItemResults
	Counter uint64
}

// RepositoryMockCreateCartItemParams contains parameters of the Repository.CreateCartItem
type RepositoryMockCreateCartItemParams struct {
	ctx context.Context
	cp1 *models.CartItem
}

// RepositoryMockCreateCartItemResults contains results of the Repository.CreateCartItem
type RepositoryMockCreateCartItemResults struct {
	err error
}

// Expect sets up expected params for Repository.CreateCartItem
func (mmCreateCartItem *mRepositoryMockCreateCartItem) Expect(ctx context.Context, cp1 *models.CartItem) *mRepositoryMockCreateCartItem {
	if mmCreateCartItem.mock.funcCreateCartItem != nil {
		mmCreateCartItem.mock.t.Fatalf("RepositoryMock.CreateCartItem mock is already set by Set")
	}

	if mmCreateCartItem.defaultExpectation == nil {
		mmCreateCartItem.defaultExpectation = &RepositoryMockCreateCartItemExpectation{}
	}

	mmCreateCartItem.defaultExpectation.params = &RepositoryMockCreateCartItemParams{ctx, cp1}
	for _, e := range mmCreateCartItem.expectations {
		if minimock.Equal(e.params, mmCreateCartItem.defaultExpectation.params) {
			mmCreateCartItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateCartItem.defaultExpectation.params)
		}
	}

	return mmCreateCartItem
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateCartItem
func (mmCreateCartItem *mRepositoryMockCreateCartItem) Inspect(f func(ctx context.Context, cp1 *models.CartItem)) *mRepositoryMockCreateCartItem {
	if mmCreateCartItem.mock.inspectFuncCreateCartItem != nil {
		mmCreateCartItem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateCartItem")
	}

	mmCreateCartItem.mock.inspectFuncCreateCartItem = f

	return mmCreateCartItem
}

// Return sets up results that will be returned by Repository.CreateCartItem
func (mmCreateCartItem *mRepositoryMockCreateCartItem) Return(err error) *RepositoryMock {
	if mmCreateCartItem.mock.funcCreateCartItem != nil {
		mmCreateCartItem.mock.t.Fatalf("RepositoryMock.CreateCartItem mock is already set by Set")
	}

	if mmCreateCartItem.defaultExpectation == nil {
		mmCreateCartItem.defaultExpectation = &RepositoryMockCreateCartItemExpectation{mock: mmCreateCartItem.mock}
	}
	mmCreateCartItem.defaultExpectation.results = &RepositoryMockCreateCartItemResults{err}
	return mmCreateCartItem.mock
}

//Set uses given function f to mock the Repository.CreateCartItem method
func (mmCreateCartItem *mRepositoryMockCreateCartItem) Set(f func(ctx context.Context, cp1 *models.CartItem) (err error)) *RepositoryMock {
	if mmCreateCartItem.defaultExpectation != nil {
		mmCreateCartItem.mock.t.Fatalf("Default expectation is already set for the Repository.CreateCartItem method")
	}

	if len(mmCreateCartItem.expectations) > 0 {
		mmCreateCartItem.mock.t.Fatalf("Some expectations are already set for the Repository.CreateCartItem method")
	}

	mmCreateCartItem.mock.funcCreateCartItem = f
	return mmCreateCartItem.mock
}

// When sets expectation for the Repository.CreateCartItem which will trigger the result defined by the following
// Then helper
func (mmCreateCartItem *mRepositoryMockCreateCartItem) When(ctx context.Context, cp1 *models.CartItem) *RepositoryMockCreateCartItemExpectation {
	if mmCreateCartItem.mock.funcCreateCartItem != nil {
		mmCreateCartItem.mock.t.Fatalf("RepositoryMock.CreateCartItem mock is already set by Set")
	}

	expectation := &RepositoryMockCreateCartItemExpectation{
		mock:   mmCreateCartItem.mock,
		params: &RepositoryMockCreateCartItemParams{ctx, cp1},
	}
	mmCreateCartItem.expectations = append(mmCreateCartItem.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateCartItem return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateCartItemExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateCartItemResults{err}
	return e.mock
}

// CreateCartItem implements Repository
func (mmCreateCartItem *RepositoryMock) CreateCartItem(ctx context.Context, cp1 *models.CartItem) (err error) {
	mm_atomic.AddUint64(&mmCreateCartItem.beforeCreateCartItemCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateCartItem.afterCreateCartItemCounter, 1)

	if mmCreateCartItem.inspectFuncCreateCartItem != nil {
		mmCreateCartItem.inspectFuncCreateCartItem(ctx, cp1)
	}

	mm_params := &RepositoryMockCreateCartItemParams{ctx, cp1}

	// Record call args
	mmCreateCartItem.CreateCartItemMock.mutex.Lock()
	mmCreateCartItem.CreateCartItemMock.callArgs = append(mmCreateCartItem.CreateCartItemMock.callArgs, mm_params)
	mmCreateCartItem.CreateCartItemMock.mutex.Unlock()

	for _, e := range mmCreateCartItem.CreateCartItemMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateCartItem.CreateCartItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateCartItem.CreateCartItemMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateCartItem.CreateCartItemMock.defaultExpectation.params
		mm_got := RepositoryMockCreateCartItemParams{ctx, cp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateCartItem.t.Errorf("RepositoryMock.CreateCartItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateCartItem.CreateCartItemMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateCartItem.t.Fatal("No results are set for the RepositoryMock.CreateCartItem")
		}
		return (*mm_results).err
	}
	if mmCreateCartItem.funcCreateCartItem != nil {
		return mmCreateCartItem.funcCreateCartItem(ctx, cp1)
	}
	mmCreateCartItem.t.Fatalf("Unexpected call to RepositoryMock.CreateCartItem. %v %v", ctx, cp1)
	return
}

// CreateCartItemAfterCounter returns a count of finished RepositoryMock.CreateCartItem invocations
func (mmCreateCartItem *RepositoryMock) CreateCartItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCartItem.afterCreateCartItemCounter)
}

// CreateCartItemBeforeCounter returns a count of RepositoryMock.CreateCartItem invocations
func (mmCreateCartItem *RepositoryMock) CreateCartItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCartItem.beforeCreateCartItemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateCartItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateCartItem *mRepositoryMockCreateCartItem) Calls() []*RepositoryMockCreateCartItemParams {
	mmCreateCartItem.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateCartItemParams, len(mmCreateCartItem.callArgs))
	copy(argCopy, mmCreateCartItem.callArgs)

	mmCreateCartItem.mutex.RUnlock()

	return argCopy
}

// MinimockCreateCartItemDone returns true if the count of the CreateCartItem invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateCartItemDone() bool {
	for _, e := range m.CreateCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCartItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCartItemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCartItem != nil && mm_atomic.LoadUint64(&m.afterCreateCartItemCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateCartItemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateCartItemInspect() {
	for _, e := range m.CreateCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateCartItem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCartItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCartItemCounter) < 1 {
		if m.CreateCartItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateCartItem")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateCartItem with params: %#v", *m.CreateCartItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCartItem != nil && mm_atomic.LoadUint64(&m.afterCreateCartItemCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateCartItem")
	}
}

type mRepositoryMockDeleteCartItem struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteCartItemExpectation
	expectations       []*RepositoryMockDeleteCartItemExpectation

	callArgs []*RepositoryMockDeleteCartItemParams
	mutex    sync.RWMutex
}

// RepositoryMockDeleteCartItemExpectation specifies expectation struct of the Repository.DeleteCartItem
type RepositoryMockDeleteCartItemExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockDeleteCartItemParams
	results *RepositoryMockDeleteCartItemResults
	Counter uint64
}

// RepositoryMockDeleteCartItemParams contains parameters of the Repository.DeleteCartItem
type RepositoryMockDeleteCartItemParams struct {
	ctx context.Context
	i1  int
	i2  int
}

// RepositoryMockDeleteCartItemResults contains results of the Repository.DeleteCartItem
type RepositoryMockDeleteCartItemResults struct {
	err error
}

// Expect sets up expected params for Repository.DeleteCartItem
func (mmDeleteCartItem *mRepositoryMockDeleteCartItem) Expect(ctx context.Context, i1 int, i2 int) *mRepositoryMockDeleteCartItem {
	if mmDeleteCartItem.mock.funcDeleteCartItem != nil {
		mmDeleteCartItem.mock.t.Fatalf("RepositoryMock.DeleteCartItem mock is already set by Set")
	}

	if mmDeleteCartItem.defaultExpectation == nil {
		mmDeleteCartItem.defaultExpectation = &RepositoryMockDeleteCartItemExpectation{}
	}

	mmDeleteCartItem.defaultExpectation.params = &RepositoryMockDeleteCartItemParams{ctx, i1, i2}
	for _, e := range mmDeleteCartItem.expectations {
		if minimock.Equal(e.params, mmDeleteCartItem.defaultExpectation.params) {
			mmDeleteCartItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCartItem.defaultExpectation.params)
		}
	}

	return mmDeleteCartItem
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteCartItem
func (mmDeleteCartItem *mRepositoryMockDeleteCartItem) Inspect(f func(ctx context.Context, i1 int, i2 int)) *mRepositoryMockDeleteCartItem {
	if mmDeleteCartItem.mock.inspectFuncDeleteCartItem != nil {
		mmDeleteCartItem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteCartItem")
	}

	mmDeleteCartItem.mock.inspectFuncDeleteCartItem = f

	return mmDeleteCartItem
}

// Return sets up results that will be returned by Repository.DeleteCartItem
func (mmDeleteCartItem *mRepositoryMockDeleteCartItem) Return(err error) *RepositoryMock {
	if mmDeleteCartItem.mock.funcDeleteCartItem != nil {
		mmDeleteCartItem.mock.t.Fatalf("RepositoryMock.DeleteCartItem mock is already set by Set")
	}

	if mmDeleteCartItem.defaultExpectation == nil {
		mmDeleteCartItem.defaultExpectation = &RepositoryMockDeleteCartItemExpectation{mock: mmDeleteCartItem.mock}
	}
	mmDeleteCartItem.defaultExpectation.results = &RepositoryMockDeleteCartItemResults{err}
	return mmDeleteCartItem.mock
}

//Set uses given function f to mock the Repository.DeleteCartItem method
func (mmDeleteCartItem *mRepositoryMockDeleteCartItem) Set(f func(ctx context.Context, i1 int, i2 int) (err error)) *RepositoryMock {
	if mmDeleteCartItem.defaultExpectation != nil {
		mmDeleteCartItem.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteCartItem method")
	}

	if len(mmDeleteCartItem.expectations) > 0 {
		mmDeleteCartItem.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteCartItem method")
	}

	mmDeleteCartItem.mock.funcDeleteCartItem = f
	return mmDeleteCartItem.mock
}

// When sets expectation for the Repository.DeleteCartItem which will trigger the result defined by the following
// Then helper
func (mmDeleteCartItem *mRepositoryMockDeleteCartItem) When(ctx context.Context, i1 int, i2 int) *RepositoryMockDeleteCartItemExpectation {
	if mmDeleteCartItem.mock.funcDeleteCartItem != nil {
		mmDeleteCartItem.mock.t.Fatalf("RepositoryMock.DeleteCartItem mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteCartItemExpectation{
		mock:   mmDeleteCartItem.mock,
		params: &RepositoryMockDeleteCartItemParams{ctx, i1, i2},
	}
	mmDeleteCartItem.expectations = append(mmDeleteCartItem.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteCartItem return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteCartItemExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteCartItemResults{err}
	return e.mock
}

// DeleteCartItem implements Repository
func (mmDeleteCartItem *RepositoryMock) DeleteCartItem(ctx context.Context, i1 int, i2 int) (err error) {
	mm_atomic.AddUint64(&mmDeleteCartItem.beforeDeleteCartItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCartItem.afterDeleteCartItemCounter, 1)

	if mmDeleteCartItem.inspectFuncDeleteCartItem != nil {
		mmDeleteCartItem.inspectFuncDeleteCartItem(ctx, i1, i2)
	}

	mm_params := &RepositoryMockDeleteCartItemParams{ctx, i1, i2}

	// Record call args
	mmDeleteCartItem.DeleteCartItemMock.mutex.Lock()
	mmDeleteCartItem.DeleteCartItemMock.callArgs = append(mmDeleteCartItem.DeleteCartItemMock.callArgs, mm_params)
	mmDeleteCartItem.DeleteCartItemMock.mutex.Unlock()

	for _, e := range mmDeleteCartItem.DeleteCartItemMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteCartItem.DeleteCartItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCartItem.DeleteCartItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCartItem.DeleteCartItemMock.defaultExpectation.params
		mm_got := RepositoryMockDeleteCartItemParams{ctx, i1, i2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCartItem.t.Errorf("RepositoryMock.DeleteCartItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCartItem.DeleteCartItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCartItem.t.Fatal("No results are set for the RepositoryMock.DeleteCartItem")
		}
		return (*mm_results).err
	}
	if mmDeleteCartItem.funcDeleteCartItem != nil {
		return mmDeleteCartItem.funcDeleteCartItem(ctx, i1, i2)
	}
	mmDeleteCartItem.t.Fatalf("Unexpected call to RepositoryMock.DeleteCartItem. %v %v %v", ctx, i1, i2)
	return
}

// DeleteCartItemAfterCounter returns a count of finished RepositoryMock.DeleteCartItem invocations
func (mmDeleteCartItem *RepositoryMock) DeleteCartItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCartItem.afterDeleteCartItemCounter)
}

// DeleteCartItemBeforeCounter returns a count of RepositoryMock.DeleteCartItem invocations
func (mmDeleteCartItem *RepositoryMock) DeleteCartItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCartItem.beforeDeleteCartItemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteCartItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCartItem *mRepositoryMockDeleteCartItem) Calls() []*RepositoryMockDeleteCartItemParams {
	mmDeleteCartItem.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteCartItemParams, len(mmDeleteCartItem.callArgs))
	copy(argCopy, mmDeleteCartItem.callArgs)

	mmDeleteCartItem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCartItemDone returns true if the count of the DeleteCartItem invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteCartItemDone() bool {
	for _, e := range m.DeleteCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCartItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCartItemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCartItem != nil && mm_atomic.LoadUint64(&m.afterDeleteCartItemCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteCartItemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteCartItemInspect() {
	for _, e := range m.DeleteCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteCartItem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCartItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCartItemCounter) < 1 {
		if m.DeleteCartItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteCartItem")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteCartItem with params: %#v", *m.DeleteCartItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCartItem != nil && mm_atomic.LoadUint64(&m.afterDeleteCartItemCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteCartItem")
	}
}

type mRepositoryMockGetCartItemsByUserId struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetCartItemsByUserIdExpectation
	expectations       []*RepositoryMockGetCartItemsByUserIdExpectation

	callArgs []*RepositoryMockGetCartItemsByUserIdParams
	mutex    sync.RWMutex
}

// RepositoryMockGetCartItemsByUserIdExpectation specifies expectation struct of the Repository.GetCartItemsByUserId
type RepositoryMockGetCartItemsByUserIdExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetCartItemsByUserIdParams
	results *RepositoryMockGetCartItemsByUserIdResults
	Counter uint64
}

// RepositoryMockGetCartItemsByUserIdParams contains parameters of the Repository.GetCartItemsByUserId
type RepositoryMockGetCartItemsByUserIdParams struct {
	ctx context.Context
	i1  int
}

// RepositoryMockGetCartItemsByUserIdResults contains results of the Repository.GetCartItemsByUserId
type RepositoryMockGetCartItemsByUserIdResults struct {
	cpa1 []*models.CartItem
	err  error
}

// Expect sets up expected params for Repository.GetCartItemsByUserId
func (mmGetCartItemsByUserId *mRepositoryMockGetCartItemsByUserId) Expect(ctx context.Context, i1 int) *mRepositoryMockGetCartItemsByUserId {
	if mmGetCartItemsByUserId.mock.funcGetCartItemsByUserId != nil {
		mmGetCartItemsByUserId.mock.t.Fatalf("RepositoryMock.GetCartItemsByUserId mock is already set by Set")
	}

	if mmGetCartItemsByUserId.defaultExpectation == nil {
		mmGetCartItemsByUserId.defaultExpectation = &RepositoryMockGetCartItemsByUserIdExpectation{}
	}

	mmGetCartItemsByUserId.defaultExpectation.params = &RepositoryMockGetCartItemsByUserIdParams{ctx, i1}
	for _, e := range mmGetCartItemsByUserId.expectations {
		if minimock.Equal(e.params, mmGetCartItemsByUserId.defaultExpectation.params) {
			mmGetCartItemsByUserId.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCartItemsByUserId.defaultExpectation.params)
		}
	}

	return mmGetCartItemsByUserId
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetCartItemsByUserId
func (mmGetCartItemsByUserId *mRepositoryMockGetCartItemsByUserId) Inspect(f func(ctx context.Context, i1 int)) *mRepositoryMockGetCartItemsByUserId {
	if mmGetCartItemsByUserId.mock.inspectFuncGetCartItemsByUserId != nil {
		mmGetCartItemsByUserId.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetCartItemsByUserId")
	}

	mmGetCartItemsByUserId.mock.inspectFuncGetCartItemsByUserId = f

	return mmGetCartItemsByUserId
}

// Return sets up results that will be returned by Repository.GetCartItemsByUserId
func (mmGetCartItemsByUserId *mRepositoryMockGetCartItemsByUserId) Return(cpa1 []*models.CartItem, err error) *RepositoryMock {
	if mmGetCartItemsByUserId.mock.funcGetCartItemsByUserId != nil {
		mmGetCartItemsByUserId.mock.t.Fatalf("RepositoryMock.GetCartItemsByUserId mock is already set by Set")
	}

	if mmGetCartItemsByUserId.defaultExpectation == nil {
		mmGetCartItemsByUserId.defaultExpectation = &RepositoryMockGetCartItemsByUserIdExpectation{mock: mmGetCartItemsByUserId.mock}
	}
	mmGetCartItemsByUserId.defaultExpectation.results = &RepositoryMockGetCartItemsByUserIdResults{cpa1, err}
	return mmGetCartItemsByUserId.mock
}

//Set uses given function f to mock the Repository.GetCartItemsByUserId method
func (mmGetCartItemsByUserId *mRepositoryMockGetCartItemsByUserId) Set(f func(ctx context.Context, i1 int) (cpa1 []*models.CartItem, err error)) *RepositoryMock {
	if mmGetCartItemsByUserId.defaultExpectation != nil {
		mmGetCartItemsByUserId.mock.t.Fatalf("Default expectation is already set for the Repository.GetCartItemsByUserId method")
	}

	if len(mmGetCartItemsByUserId.expectations) > 0 {
		mmGetCartItemsByUserId.mock.t.Fatalf("Some expectations are already set for the Repository.GetCartItemsByUserId method")
	}

	mmGetCartItemsByUserId.mock.funcGetCartItemsByUserId = f
	return mmGetCartItemsByUserId.mock
}

// When sets expectation for the Repository.GetCartItemsByUserId which will trigger the result defined by the following
// Then helper
func (mmGetCartItemsByUserId *mRepositoryMockGetCartItemsByUserId) When(ctx context.Context, i1 int) *RepositoryMockGetCartItemsByUserIdExpectation {
	if mmGetCartItemsByUserId.mock.funcGetCartItemsByUserId != nil {
		mmGetCartItemsByUserId.mock.t.Fatalf("RepositoryMock.GetCartItemsByUserId mock is already set by Set")
	}

	expectation := &RepositoryMockGetCartItemsByUserIdExpectation{
		mock:   mmGetCartItemsByUserId.mock,
		params: &RepositoryMockGetCartItemsByUserIdParams{ctx, i1},
	}
	mmGetCartItemsByUserId.expectations = append(mmGetCartItemsByUserId.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetCartItemsByUserId return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetCartItemsByUserIdExpectation) Then(cpa1 []*models.CartItem, err error) *RepositoryMock {
	e.results = &RepositoryMockGetCartItemsByUserIdResults{cpa1, err}
	return e.mock
}

// GetCartItemsByUserId implements Repository
func (mmGetCartItemsByUserId *RepositoryMock) GetCartItemsByUserId(ctx context.Context, i1 int) (cpa1 []*models.CartItem, err error) {
	mm_atomic.AddUint64(&mmGetCartItemsByUserId.beforeGetCartItemsByUserIdCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCartItemsByUserId.afterGetCartItemsByUserIdCounter, 1)

	if mmGetCartItemsByUserId.inspectFuncGetCartItemsByUserId != nil {
		mmGetCartItemsByUserId.inspectFuncGetCartItemsByUserId(ctx, i1)
	}

	mm_params := &RepositoryMockGetCartItemsByUserIdParams{ctx, i1}

	// Record call args
	mmGetCartItemsByUserId.GetCartItemsByUserIdMock.mutex.Lock()
	mmGetCartItemsByUserId.GetCartItemsByUserIdMock.callArgs = append(mmGetCartItemsByUserId.GetCartItemsByUserIdMock.callArgs, mm_params)
	mmGetCartItemsByUserId.GetCartItemsByUserIdMock.mutex.Unlock()

	for _, e := range mmGetCartItemsByUserId.GetCartItemsByUserIdMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cpa1, e.results.err
		}
	}

	if mmGetCartItemsByUserId.GetCartItemsByUserIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCartItemsByUserId.GetCartItemsByUserIdMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCartItemsByUserId.GetCartItemsByUserIdMock.defaultExpectation.params
		mm_got := RepositoryMockGetCartItemsByUserIdParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCartItemsByUserId.t.Errorf("RepositoryMock.GetCartItemsByUserId got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCartItemsByUserId.GetCartItemsByUserIdMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCartItemsByUserId.t.Fatal("No results are set for the RepositoryMock.GetCartItemsByUserId")
		}
		return (*mm_results).cpa1, (*mm_results).err
	}
	if mmGetCartItemsByUserId.funcGetCartItemsByUserId != nil {
		return mmGetCartItemsByUserId.funcGetCartItemsByUserId(ctx, i1)
	}
	mmGetCartItemsByUserId.t.Fatalf("Unexpected call to RepositoryMock.GetCartItemsByUserId. %v %v", ctx, i1)
	return
}

// GetCartItemsByUserIdAfterCounter returns a count of finished RepositoryMock.GetCartItemsByUserId invocations
func (mmGetCartItemsByUserId *RepositoryMock) GetCartItemsByUserIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartItemsByUserId.afterGetCartItemsByUserIdCounter)
}

// GetCartItemsByUserIdBeforeCounter returns a count of RepositoryMock.GetCartItemsByUserId invocations
func (mmGetCartItemsByUserId *RepositoryMock) GetCartItemsByUserIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartItemsByUserId.beforeGetCartItemsByUserIdCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetCartItemsByUserId.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCartItemsByUserId *mRepositoryMockGetCartItemsByUserId) Calls() []*RepositoryMockGetCartItemsByUserIdParams {
	mmGetCartItemsByUserId.mutex.RLock()

	argCopy := make([]*RepositoryMockGetCartItemsByUserIdParams, len(mmGetCartItemsByUserId.callArgs))
	copy(argCopy, mmGetCartItemsByUserId.callArgs)

	mmGetCartItemsByUserId.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartItemsByUserIdDone returns true if the count of the GetCartItemsByUserId invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetCartItemsByUserIdDone() bool {
	for _, e := range m.GetCartItemsByUserIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartItemsByUserIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartItemsByUserIdCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartItemsByUserId != nil && mm_atomic.LoadUint64(&m.afterGetCartItemsByUserIdCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCartItemsByUserIdInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetCartItemsByUserIdInspect() {
	for _, e := range m.GetCartItemsByUserIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetCartItemsByUserId with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartItemsByUserIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartItemsByUserIdCounter) < 1 {
		if m.GetCartItemsByUserIdMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetCartItemsByUserId")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetCartItemsByUserId with params: %#v", *m.GetCartItemsByUserIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartItemsByUserId != nil && mm_atomic.LoadUint64(&m.afterGetCartItemsByUserIdCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetCartItemsByUserId")
	}
}

type mRepositoryMockReadCartItem struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockReadCartItemExpectation
	expectations       []*RepositoryMockReadCartItemExpectation

	callArgs []*RepositoryMockReadCartItemParams
	mutex    sync.RWMutex
}

// RepositoryMockReadCartItemExpectation specifies expectation struct of the Repository.ReadCartItem
type RepositoryMockReadCartItemExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockReadCartItemParams
	results *RepositoryMockReadCartItemResults
	Counter uint64
}

// RepositoryMockReadCartItemParams contains parameters of the Repository.ReadCartItem
type RepositoryMockReadCartItemParams struct {
	ctx context.Context
	i1  int
	i2  int
}

// RepositoryMockReadCartItemResults contains results of the Repository.ReadCartItem
type RepositoryMockReadCartItemResults struct {
	cp1 *models.CartItem
	err error
}

// Expect sets up expected params for Repository.ReadCartItem
func (mmReadCartItem *mRepositoryMockReadCartItem) Expect(ctx context.Context, i1 int, i2 int) *mRepositoryMockReadCartItem {
	if mmReadCartItem.mock.funcReadCartItem != nil {
		mmReadCartItem.mock.t.Fatalf("RepositoryMock.ReadCartItem mock is already set by Set")
	}

	if mmReadCartItem.defaultExpectation == nil {
		mmReadCartItem.defaultExpectation = &RepositoryMockReadCartItemExpectation{}
	}

	mmReadCartItem.defaultExpectation.params = &RepositoryMockReadCartItemParams{ctx, i1, i2}
	for _, e := range mmReadCartItem.expectations {
		if minimock.Equal(e.params, mmReadCartItem.defaultExpectation.params) {
			mmReadCartItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadCartItem.defaultExpectation.params)
		}
	}

	return mmReadCartItem
}

// Inspect accepts an inspector function that has same arguments as the Repository.ReadCartItem
func (mmReadCartItem *mRepositoryMockReadCartItem) Inspect(f func(ctx context.Context, i1 int, i2 int)) *mRepositoryMockReadCartItem {
	if mmReadCartItem.mock.inspectFuncReadCartItem != nil {
		mmReadCartItem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ReadCartItem")
	}

	mmReadCartItem.mock.inspectFuncReadCartItem = f

	return mmReadCartItem
}

// Return sets up results that will be returned by Repository.ReadCartItem
func (mmReadCartItem *mRepositoryMockReadCartItem) Return(cp1 *models.CartItem, err error) *RepositoryMock {
	if mmReadCartItem.mock.funcReadCartItem != nil {
		mmReadCartItem.mock.t.Fatalf("RepositoryMock.ReadCartItem mock is already set by Set")
	}

	if mmReadCartItem.defaultExpectation == nil {
		mmReadCartItem.defaultExpectation = &RepositoryMockReadCartItemExpectation{mock: mmReadCartItem.mock}
	}
	mmReadCartItem.defaultExpectation.results = &RepositoryMockReadCartItemResults{cp1, err}
	return mmReadCartItem.mock
}

//Set uses given function f to mock the Repository.ReadCartItem method
func (mmReadCartItem *mRepositoryMockReadCartItem) Set(f func(ctx context.Context, i1 int, i2 int) (cp1 *models.CartItem, err error)) *RepositoryMock {
	if mmReadCartItem.defaultExpectation != nil {
		mmReadCartItem.mock.t.Fatalf("Default expectation is already set for the Repository.ReadCartItem method")
	}

	if len(mmReadCartItem.expectations) > 0 {
		mmReadCartItem.mock.t.Fatalf("Some expectations are already set for the Repository.ReadCartItem method")
	}

	mmReadCartItem.mock.funcReadCartItem = f
	return mmReadCartItem.mock
}

// When sets expectation for the Repository.ReadCartItem which will trigger the result defined by the following
// Then helper
func (mmReadCartItem *mRepositoryMockReadCartItem) When(ctx context.Context, i1 int, i2 int) *RepositoryMockReadCartItemExpectation {
	if mmReadCartItem.mock.funcReadCartItem != nil {
		mmReadCartItem.mock.t.Fatalf("RepositoryMock.ReadCartItem mock is already set by Set")
	}

	expectation := &RepositoryMockReadCartItemExpectation{
		mock:   mmReadCartItem.mock,
		params: &RepositoryMockReadCartItemParams{ctx, i1, i2},
	}
	mmReadCartItem.expectations = append(mmReadCartItem.expectations, expectation)
	return expectation
}

// Then sets up Repository.ReadCartItem return parameters for the expectation previously defined by the When method
func (e *RepositoryMockReadCartItemExpectation) Then(cp1 *models.CartItem, err error) *RepositoryMock {
	e.results = &RepositoryMockReadCartItemResults{cp1, err}
	return e.mock
}

// ReadCartItem implements Repository
func (mmReadCartItem *RepositoryMock) ReadCartItem(ctx context.Context, i1 int, i2 int) (cp1 *models.CartItem, err error) {
	mm_atomic.AddUint64(&mmReadCartItem.beforeReadCartItemCounter, 1)
	defer mm_atomic.AddUint64(&mmReadCartItem.afterReadCartItemCounter, 1)

	if mmReadCartItem.inspectFuncReadCartItem != nil {
		mmReadCartItem.inspectFuncReadCartItem(ctx, i1, i2)
	}

	mm_params := &RepositoryMockReadCartItemParams{ctx, i1, i2}

	// Record call args
	mmReadCartItem.ReadCartItemMock.mutex.Lock()
	mmReadCartItem.ReadCartItemMock.callArgs = append(mmReadCartItem.ReadCartItemMock.callArgs, mm_params)
	mmReadCartItem.ReadCartItemMock.mutex.Unlock()

	for _, e := range mmReadCartItem.ReadCartItemMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmReadCartItem.ReadCartItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadCartItem.ReadCartItemMock.defaultExpectation.Counter, 1)
		mm_want := mmReadCartItem.ReadCartItemMock.defaultExpectation.params
		mm_got := RepositoryMockReadCartItemParams{ctx, i1, i2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadCartItem.t.Errorf("RepositoryMock.ReadCartItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadCartItem.ReadCartItemMock.defaultExpectation.results
		if mm_results == nil {
			mmReadCartItem.t.Fatal("No results are set for the RepositoryMock.ReadCartItem")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmReadCartItem.funcReadCartItem != nil {
		return mmReadCartItem.funcReadCartItem(ctx, i1, i2)
	}
	mmReadCartItem.t.Fatalf("Unexpected call to RepositoryMock.ReadCartItem. %v %v %v", ctx, i1, i2)
	return
}

// ReadCartItemAfterCounter returns a count of finished RepositoryMock.ReadCartItem invocations
func (mmReadCartItem *RepositoryMock) ReadCartItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadCartItem.afterReadCartItemCounter)
}

// ReadCartItemBeforeCounter returns a count of RepositoryMock.ReadCartItem invocations
func (mmReadCartItem *RepositoryMock) ReadCartItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadCartItem.beforeReadCartItemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ReadCartItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadCartItem *mRepositoryMockReadCartItem) Calls() []*RepositoryMockReadCartItemParams {
	mmReadCartItem.mutex.RLock()

	argCopy := make([]*RepositoryMockReadCartItemParams, len(mmReadCartItem.callArgs))
	copy(argCopy, mmReadCartItem.callArgs)

	mmReadCartItem.mutex.RUnlock()

	return argCopy
}

// MinimockReadCartItemDone returns true if the count of the ReadCartItem invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockReadCartItemDone() bool {
	for _, e := range m.ReadCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadCartItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCartItemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadCartItem != nil && mm_atomic.LoadUint64(&m.afterReadCartItemCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadCartItemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockReadCartItemInspect() {
	for _, e := range m.ReadCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ReadCartItem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadCartItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCartItemCounter) < 1 {
		if m.ReadCartItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ReadCartItem")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ReadCartItem with params: %#v", *m.ReadCartItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadCartItem != nil && mm_atomic.LoadUint64(&m.afterReadCartItemCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.ReadCartItem")
	}
}

type mRepositoryMockUpdateCartItem struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateCartItemExpectation
	expectations       []*RepositoryMockUpdateCartItemExpectation

	callArgs []*RepositoryMockUpdateCartItemParams
	mutex    sync.RWMutex
}

// RepositoryMockUpdateCartItemExpectation specifies expectation struct of the Repository.UpdateCartItem
type RepositoryMockUpdateCartItemExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockUpdateCartItemParams
	results *RepositoryMockUpdateCartItemResults
	Counter uint64
}

// RepositoryMockUpdateCartItemParams contains parameters of the Repository.UpdateCartItem
type RepositoryMockUpdateCartItemParams struct {
	ctx context.Context
	cp1 *models.CartItem
}

// RepositoryMockUpdateCartItemResults contains results of the Repository.UpdateCartItem
type RepositoryMockUpdateCartItemResults struct {
	err error
}

// Expect sets up expected params for Repository.UpdateCartItem
func (mmUpdateCartItem *mRepositoryMockUpdateCartItem) Expect(ctx context.Context, cp1 *models.CartItem) *mRepositoryMockUpdateCartItem {
	if mmUpdateCartItem.mock.funcUpdateCartItem != nil {
		mmUpdateCartItem.mock.t.Fatalf("RepositoryMock.UpdateCartItem mock is already set by Set")
	}

	if mmUpdateCartItem.defaultExpectation == nil {
		mmUpdateCartItem.defaultExpectation = &RepositoryMockUpdateCartItemExpectation{}
	}

	mmUpdateCartItem.defaultExpectation.params = &RepositoryMockUpdateCartItemParams{ctx, cp1}
	for _, e := range mmUpdateCartItem.expectations {
		if minimock.Equal(e.params, mmUpdateCartItem.defaultExpectation.params) {
			mmUpdateCartItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateCartItem.defaultExpectation.params)
		}
	}

	return mmUpdateCartItem
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateCartItem
func (mmUpdateCartItem *mRepositoryMockUpdateCartItem) Inspect(f func(ctx context.Context, cp1 *models.CartItem)) *mRepositoryMockUpdateCartItem {
	if mmUpdateCartItem.mock.inspectFuncUpdateCartItem != nil {
		mmUpdateCartItem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateCartItem")
	}

	mmUpdateCartItem.mock.inspectFuncUpdateCartItem = f

	return mmUpdateCartItem
}

// Return sets up results that will be returned by Repository.UpdateCartItem
func (mmUpdateCartItem *mRepositoryMockUpdateCartItem) Return(err error) *RepositoryMock {
	if mmUpdateCartItem.mock.funcUpdateCartItem != nil {
		mmUpdateCartItem.mock.t.Fatalf("RepositoryMock.UpdateCartItem mock is already set by Set")
	}

	if mmUpdateCartItem.defaultExpectation == nil {
		mmUpdateCartItem.defaultExpectation = &RepositoryMockUpdateCartItemExpectation{mock: mmUpdateCartItem.mock}
	}
	mmUpdateCartItem.defaultExpectation.results = &RepositoryMockUpdateCartItemResults{err}
	return mmUpdateCartItem.mock
}

//Set uses given function f to mock the Repository.UpdateCartItem method
func (mmUpdateCartItem *mRepositoryMockUpdateCartItem) Set(f func(ctx context.Context, cp1 *models.CartItem) (err error)) *RepositoryMock {
	if mmUpdateCartItem.defaultExpectation != nil {
		mmUpdateCartItem.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateCartItem method")
	}

	if len(mmUpdateCartItem.expectations) > 0 {
		mmUpdateCartItem.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateCartItem method")
	}

	mmUpdateCartItem.mock.funcUpdateCartItem = f
	return mmUpdateCartItem.mock
}

// When sets expectation for the Repository.UpdateCartItem which will trigger the result defined by the following
// Then helper
func (mmUpdateCartItem *mRepositoryMockUpdateCartItem) When(ctx context.Context, cp1 *models.CartItem) *RepositoryMockUpdateCartItemExpectation {
	if mmUpdateCartItem.mock.funcUpdateCartItem != nil {
		mmUpdateCartItem.mock.t.Fatalf("RepositoryMock.UpdateCartItem mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateCartItemExpectation{
		mock:   mmUpdateCartItem.mock,
		params: &RepositoryMockUpdateCartItemParams{ctx, cp1},
	}
	mmUpdateCartItem.expectations = append(mmUpdateCartItem.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateCartItem return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateCartItemExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateCartItemResults{err}
	return e.mock
}

// UpdateCartItem implements Repository
func (mmUpdateCartItem *RepositoryMock) UpdateCartItem(ctx context.Context, cp1 *models.CartItem) (err error) {
	mm_atomic.AddUint64(&mmUpdateCartItem.beforeUpdateCartItemCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateCartItem.afterUpdateCartItemCounter, 1)

	if mmUpdateCartItem.inspectFuncUpdateCartItem != nil {
		mmUpdateCartItem.inspectFuncUpdateCartItem(ctx, cp1)
	}

	mm_params := &RepositoryMockUpdateCartItemParams{ctx, cp1}

	// Record call args
	mmUpdateCartItem.UpdateCartItemMock.mutex.Lock()
	mmUpdateCartItem.UpdateCartItemMock.callArgs = append(mmUpdateCartItem.UpdateCartItemMock.callArgs, mm_params)
	mmUpdateCartItem.UpdateCartItemMock.mutex.Unlock()

	for _, e := range mmUpdateCartItem.UpdateCartItemMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateCartItem.UpdateCartItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateCartItem.UpdateCartItemMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateCartItem.UpdateCartItemMock.defaultExpectation.params
		mm_got := RepositoryMockUpdateCartItemParams{ctx, cp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateCartItem.t.Errorf("RepositoryMock.UpdateCartItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateCartItem.UpdateCartItemMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateCartItem.t.Fatal("No results are set for the RepositoryMock.UpdateCartItem")
		}
		return (*mm_results).err
	}
	if mmUpdateCartItem.funcUpdateCartItem != nil {
		return mmUpdateCartItem.funcUpdateCartItem(ctx, cp1)
	}
	mmUpdateCartItem.t.Fatalf("Unexpected call to RepositoryMock.UpdateCartItem. %v %v", ctx, cp1)
	return
}

// UpdateCartItemAfterCounter returns a count of finished RepositoryMock.UpdateCartItem invocations
func (mmUpdateCartItem *RepositoryMock) UpdateCartItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCartItem.afterUpdateCartItemCounter)
}

// UpdateCartItemBeforeCounter returns a count of RepositoryMock.UpdateCartItem invocations
func (mmUpdateCartItem *RepositoryMock) UpdateCartItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCartItem.beforeUpdateCartItemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateCartItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateCartItem *mRepositoryMockUpdateCartItem) Calls() []*RepositoryMockUpdateCartItemParams {
	mmUpdateCartItem.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateCartItemParams, len(mmUpdateCartItem.callArgs))
	copy(argCopy, mmUpdateCartItem.callArgs)

	mmUpdateCartItem.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateCartItemDone returns true if the count of the UpdateCartItem invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateCartItemDone() bool {
	for _, e := range m.UpdateCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCartItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCartItemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCartItem != nil && mm_atomic.LoadUint64(&m.afterUpdateCartItemCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateCartItemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateCartItemInspect() {
	for _, e := range m.UpdateCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateCartItem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCartItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCartItemCounter) < 1 {
		if m.UpdateCartItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdateCartItem")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateCartItem with params: %#v", *m.UpdateCartItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCartItem != nil && mm_atomic.LoadUint64(&m.afterUpdateCartItemCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdateCartItem")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateCartItemInspect()

		m.MinimockDeleteCartItemInspect()

		m.MinimockGetCartItemsByUserIdInspect()

		m.MinimockReadCartItemInspect()

		m.MinimockUpdateCartItemInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateCartItemDone() &&
		m.MinimockDeleteCartItemDone() &&
		m.MinimockGetCartItemsByUserIdDone() &&
		m.MinimockReadCartItemDone() &&
		m.MinimockUpdateCartItemDone()
}
