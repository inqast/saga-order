package app

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/inqast/saga-order/internal/order/app.Repository -o ./repository_mock_test.go -n RepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/inqast/saga-order/internal/models"
)

// RepositoryMock implements Repository
type RepositoryMock struct {
	t minimock.Tester

	funcCreateOrder          func(ctx context.Context, op1 *models.Order) (i1 int, err error)
	inspectFuncCreateOrder   func(ctx context.Context, op1 *models.Order)
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mRepositoryMockCreateOrder

	funcDeleteOrder          func(ctx context.Context, i1 int) (err error)
	inspectFuncDeleteOrder   func(ctx context.Context, i1 int)
	afterDeleteOrderCounter  uint64
	beforeDeleteOrderCounter uint64
	DeleteOrderMock          mRepositoryMockDeleteOrder

	funcGetOrdersByUserId          func(ctx context.Context, i1 int) (opa1 []*models.Order, err error)
	inspectFuncGetOrdersByUserId   func(ctx context.Context, i1 int)
	afterGetOrdersByUserIdCounter  uint64
	beforeGetOrdersByUserIdCounter uint64
	GetOrdersByUserIdMock          mRepositoryMockGetOrdersByUserId

	funcReadOrder          func(ctx context.Context, i1 int) (op1 *models.Order, err error)
	inspectFuncReadOrder   func(ctx context.Context, i1 int)
	afterReadOrderCounter  uint64
	beforeReadOrderCounter uint64
	ReadOrderMock          mRepositoryMockReadOrder

	funcUpdateOrder          func(ctx context.Context, i1 int, i2 int) (err error)
	inspectFuncUpdateOrder   func(ctx context.Context, i1 int, i2 int)
	afterUpdateOrderCounter  uint64
	beforeUpdateOrderCounter uint64
	UpdateOrderMock          mRepositoryMockUpdateOrder
}

// NewRepositoryMock returns a mock for Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateOrderMock = mRepositoryMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*RepositoryMockCreateOrderParams{}

	m.DeleteOrderMock = mRepositoryMockDeleteOrder{mock: m}
	m.DeleteOrderMock.callArgs = []*RepositoryMockDeleteOrderParams{}

	m.GetOrdersByUserIdMock = mRepositoryMockGetOrdersByUserId{mock: m}
	m.GetOrdersByUserIdMock.callArgs = []*RepositoryMockGetOrdersByUserIdParams{}

	m.ReadOrderMock = mRepositoryMockReadOrder{mock: m}
	m.ReadOrderMock.callArgs = []*RepositoryMockReadOrderParams{}

	m.UpdateOrderMock = mRepositoryMockUpdateOrder{mock: m}
	m.UpdateOrderMock.callArgs = []*RepositoryMockUpdateOrderParams{}

	return m
}

type mRepositoryMockCreateOrder struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateOrderExpectation
	expectations       []*RepositoryMockCreateOrderExpectation

	callArgs []*RepositoryMockCreateOrderParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateOrderExpectation specifies expectation struct of the Repository.CreateOrder
type RepositoryMockCreateOrderExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateOrderParams
	results *RepositoryMockCreateOrderResults
	Counter uint64
}

// RepositoryMockCreateOrderParams contains parameters of the Repository.CreateOrder
type RepositoryMockCreateOrderParams struct {
	ctx context.Context
	op1 *models.Order
}

// RepositoryMockCreateOrderResults contains results of the Repository.CreateOrder
type RepositoryMockCreateOrderResults struct {
	i1  int
	err error
}

// Expect sets up expected params for Repository.CreateOrder
func (mmCreateOrder *mRepositoryMockCreateOrder) Expect(ctx context.Context, op1 *models.Order) *mRepositoryMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("RepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &RepositoryMockCreateOrderExpectation{}
	}

	mmCreateOrder.defaultExpectation.params = &RepositoryMockCreateOrderParams{ctx, op1}
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateOrder
func (mmCreateOrder *mRepositoryMockCreateOrder) Inspect(f func(ctx context.Context, op1 *models.Order)) *mRepositoryMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by Repository.CreateOrder
func (mmCreateOrder *mRepositoryMockCreateOrder) Return(i1 int, err error) *RepositoryMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("RepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &RepositoryMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &RepositoryMockCreateOrderResults{i1, err}
	return mmCreateOrder.mock
}

//Set uses given function f to mock the Repository.CreateOrder method
func (mmCreateOrder *mRepositoryMockCreateOrder) Set(f func(ctx context.Context, op1 *models.Order) (i1 int, err error)) *RepositoryMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the Repository.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the Repository.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	return mmCreateOrder.mock
}

// When sets expectation for the Repository.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mRepositoryMockCreateOrder) When(ctx context.Context, op1 *models.Order) *RepositoryMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("RepositoryMock.CreateOrder mock is already set by Set")
	}

	expectation := &RepositoryMockCreateOrderExpectation{
		mock:   mmCreateOrder.mock,
		params: &RepositoryMockCreateOrderParams{ctx, op1},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateOrder return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateOrderExpectation) Then(i1 int, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateOrderResults{i1, err}
	return e.mock
}

// CreateOrder implements Repository
func (mmCreateOrder *RepositoryMock) CreateOrder(ctx context.Context, op1 *models.Order) (i1 int, err error) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(ctx, op1)
	}

	mm_params := &RepositoryMockCreateOrderParams{ctx, op1}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_got := RepositoryMockCreateOrderParams{ctx, op1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("RepositoryMock.CreateOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrder.t.Fatal("No results are set for the RepositoryMock.CreateOrder")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(ctx, op1)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to RepositoryMock.CreateOrder. %v %v", ctx, op1)
	return
}

// CreateOrderAfterCounter returns a count of finished RepositoryMock.CreateOrder invocations
func (mmCreateOrder *RepositoryMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of RepositoryMock.CreateOrder invocations
func (mmCreateOrder *RepositoryMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mRepositoryMockCreateOrder) Calls() []*RepositoryMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateOrderDone() bool {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateOrder")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateOrder with params: %#v", *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateOrder")
	}
}

type mRepositoryMockDeleteOrder struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteOrderExpectation
	expectations       []*RepositoryMockDeleteOrderExpectation

	callArgs []*RepositoryMockDeleteOrderParams
	mutex    sync.RWMutex
}

// RepositoryMockDeleteOrderExpectation specifies expectation struct of the Repository.DeleteOrder
type RepositoryMockDeleteOrderExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockDeleteOrderParams
	results *RepositoryMockDeleteOrderResults
	Counter uint64
}

// RepositoryMockDeleteOrderParams contains parameters of the Repository.DeleteOrder
type RepositoryMockDeleteOrderParams struct {
	ctx context.Context
	i1  int
}

// RepositoryMockDeleteOrderResults contains results of the Repository.DeleteOrder
type RepositoryMockDeleteOrderResults struct {
	err error
}

// Expect sets up expected params for Repository.DeleteOrder
func (mmDeleteOrder *mRepositoryMockDeleteOrder) Expect(ctx context.Context, i1 int) *mRepositoryMockDeleteOrder {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("RepositoryMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &RepositoryMockDeleteOrderExpectation{}
	}

	mmDeleteOrder.defaultExpectation.params = &RepositoryMockDeleteOrderParams{ctx, i1}
	for _, e := range mmDeleteOrder.expectations {
		if minimock.Equal(e.params, mmDeleteOrder.defaultExpectation.params) {
			mmDeleteOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteOrder.defaultExpectation.params)
		}
	}

	return mmDeleteOrder
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteOrder
func (mmDeleteOrder *mRepositoryMockDeleteOrder) Inspect(f func(ctx context.Context, i1 int)) *mRepositoryMockDeleteOrder {
	if mmDeleteOrder.mock.inspectFuncDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteOrder")
	}

	mmDeleteOrder.mock.inspectFuncDeleteOrder = f

	return mmDeleteOrder
}

// Return sets up results that will be returned by Repository.DeleteOrder
func (mmDeleteOrder *mRepositoryMockDeleteOrder) Return(err error) *RepositoryMock {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("RepositoryMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &RepositoryMockDeleteOrderExpectation{mock: mmDeleteOrder.mock}
	}
	mmDeleteOrder.defaultExpectation.results = &RepositoryMockDeleteOrderResults{err}
	return mmDeleteOrder.mock
}

//Set uses given function f to mock the Repository.DeleteOrder method
func (mmDeleteOrder *mRepositoryMockDeleteOrder) Set(f func(ctx context.Context, i1 int) (err error)) *RepositoryMock {
	if mmDeleteOrder.defaultExpectation != nil {
		mmDeleteOrder.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteOrder method")
	}

	if len(mmDeleteOrder.expectations) > 0 {
		mmDeleteOrder.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteOrder method")
	}

	mmDeleteOrder.mock.funcDeleteOrder = f
	return mmDeleteOrder.mock
}

// When sets expectation for the Repository.DeleteOrder which will trigger the result defined by the following
// Then helper
func (mmDeleteOrder *mRepositoryMockDeleteOrder) When(ctx context.Context, i1 int) *RepositoryMockDeleteOrderExpectation {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("RepositoryMock.DeleteOrder mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteOrderExpectation{
		mock:   mmDeleteOrder.mock,
		params: &RepositoryMockDeleteOrderParams{ctx, i1},
	}
	mmDeleteOrder.expectations = append(mmDeleteOrder.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteOrder return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteOrderExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteOrderResults{err}
	return e.mock
}

// DeleteOrder implements Repository
func (mmDeleteOrder *RepositoryMock) DeleteOrder(ctx context.Context, i1 int) (err error) {
	mm_atomic.AddUint64(&mmDeleteOrder.beforeDeleteOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteOrder.afterDeleteOrderCounter, 1)

	if mmDeleteOrder.inspectFuncDeleteOrder != nil {
		mmDeleteOrder.inspectFuncDeleteOrder(ctx, i1)
	}

	mm_params := &RepositoryMockDeleteOrderParams{ctx, i1}

	// Record call args
	mmDeleteOrder.DeleteOrderMock.mutex.Lock()
	mmDeleteOrder.DeleteOrderMock.callArgs = append(mmDeleteOrder.DeleteOrderMock.callArgs, mm_params)
	mmDeleteOrder.DeleteOrderMock.mutex.Unlock()

	for _, e := range mmDeleteOrder.DeleteOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteOrder.DeleteOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteOrder.DeleteOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteOrder.DeleteOrderMock.defaultExpectation.params
		mm_got := RepositoryMockDeleteOrderParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteOrder.t.Errorf("RepositoryMock.DeleteOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteOrder.DeleteOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteOrder.t.Fatal("No results are set for the RepositoryMock.DeleteOrder")
		}
		return (*mm_results).err
	}
	if mmDeleteOrder.funcDeleteOrder != nil {
		return mmDeleteOrder.funcDeleteOrder(ctx, i1)
	}
	mmDeleteOrder.t.Fatalf("Unexpected call to RepositoryMock.DeleteOrder. %v %v", ctx, i1)
	return
}

// DeleteOrderAfterCounter returns a count of finished RepositoryMock.DeleteOrder invocations
func (mmDeleteOrder *RepositoryMock) DeleteOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrder.afterDeleteOrderCounter)
}

// DeleteOrderBeforeCounter returns a count of RepositoryMock.DeleteOrder invocations
func (mmDeleteOrder *RepositoryMock) DeleteOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrder.beforeDeleteOrderCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteOrder *mRepositoryMockDeleteOrder) Calls() []*RepositoryMockDeleteOrderParams {
	mmDeleteOrder.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteOrderParams, len(mmDeleteOrder.callArgs))
	copy(argCopy, mmDeleteOrder.callArgs)

	mmDeleteOrder.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteOrderDone returns true if the count of the DeleteOrder invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteOrderDone() bool {
	for _, e := range m.DeleteOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteOrder != nil && mm_atomic.LoadUint64(&m.afterDeleteOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteOrderInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteOrderInspect() {
	for _, e := range m.DeleteOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteOrderCounter) < 1 {
		if m.DeleteOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteOrder")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteOrder with params: %#v", *m.DeleteOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteOrder != nil && mm_atomic.LoadUint64(&m.afterDeleteOrderCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteOrder")
	}
}

type mRepositoryMockGetOrdersByUserId struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetOrdersByUserIdExpectation
	expectations       []*RepositoryMockGetOrdersByUserIdExpectation

	callArgs []*RepositoryMockGetOrdersByUserIdParams
	mutex    sync.RWMutex
}

// RepositoryMockGetOrdersByUserIdExpectation specifies expectation struct of the Repository.GetOrdersByUserId
type RepositoryMockGetOrdersByUserIdExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetOrdersByUserIdParams
	results *RepositoryMockGetOrdersByUserIdResults
	Counter uint64
}

// RepositoryMockGetOrdersByUserIdParams contains parameters of the Repository.GetOrdersByUserId
type RepositoryMockGetOrdersByUserIdParams struct {
	ctx context.Context
	i1  int
}

// RepositoryMockGetOrdersByUserIdResults contains results of the Repository.GetOrdersByUserId
type RepositoryMockGetOrdersByUserIdResults struct {
	opa1 []*models.Order
	err  error
}

// Expect sets up expected params for Repository.GetOrdersByUserId
func (mmGetOrdersByUserId *mRepositoryMockGetOrdersByUserId) Expect(ctx context.Context, i1 int) *mRepositoryMockGetOrdersByUserId {
	if mmGetOrdersByUserId.mock.funcGetOrdersByUserId != nil {
		mmGetOrdersByUserId.mock.t.Fatalf("RepositoryMock.GetOrdersByUserId mock is already set by Set")
	}

	if mmGetOrdersByUserId.defaultExpectation == nil {
		mmGetOrdersByUserId.defaultExpectation = &RepositoryMockGetOrdersByUserIdExpectation{}
	}

	mmGetOrdersByUserId.defaultExpectation.params = &RepositoryMockGetOrdersByUserIdParams{ctx, i1}
	for _, e := range mmGetOrdersByUserId.expectations {
		if minimock.Equal(e.params, mmGetOrdersByUserId.defaultExpectation.params) {
			mmGetOrdersByUserId.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrdersByUserId.defaultExpectation.params)
		}
	}

	return mmGetOrdersByUserId
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetOrdersByUserId
func (mmGetOrdersByUserId *mRepositoryMockGetOrdersByUserId) Inspect(f func(ctx context.Context, i1 int)) *mRepositoryMockGetOrdersByUserId {
	if mmGetOrdersByUserId.mock.inspectFuncGetOrdersByUserId != nil {
		mmGetOrdersByUserId.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetOrdersByUserId")
	}

	mmGetOrdersByUserId.mock.inspectFuncGetOrdersByUserId = f

	return mmGetOrdersByUserId
}

// Return sets up results that will be returned by Repository.GetOrdersByUserId
func (mmGetOrdersByUserId *mRepositoryMockGetOrdersByUserId) Return(opa1 []*models.Order, err error) *RepositoryMock {
	if mmGetOrdersByUserId.mock.funcGetOrdersByUserId != nil {
		mmGetOrdersByUserId.mock.t.Fatalf("RepositoryMock.GetOrdersByUserId mock is already set by Set")
	}

	if mmGetOrdersByUserId.defaultExpectation == nil {
		mmGetOrdersByUserId.defaultExpectation = &RepositoryMockGetOrdersByUserIdExpectation{mock: mmGetOrdersByUserId.mock}
	}
	mmGetOrdersByUserId.defaultExpectation.results = &RepositoryMockGetOrdersByUserIdResults{opa1, err}
	return mmGetOrdersByUserId.mock
}

//Set uses given function f to mock the Repository.GetOrdersByUserId method
func (mmGetOrdersByUserId *mRepositoryMockGetOrdersByUserId) Set(f func(ctx context.Context, i1 int) (opa1 []*models.Order, err error)) *RepositoryMock {
	if mmGetOrdersByUserId.defaultExpectation != nil {
		mmGetOrdersByUserId.mock.t.Fatalf("Default expectation is already set for the Repository.GetOrdersByUserId method")
	}

	if len(mmGetOrdersByUserId.expectations) > 0 {
		mmGetOrdersByUserId.mock.t.Fatalf("Some expectations are already set for the Repository.GetOrdersByUserId method")
	}

	mmGetOrdersByUserId.mock.funcGetOrdersByUserId = f
	return mmGetOrdersByUserId.mock
}

// When sets expectation for the Repository.GetOrdersByUserId which will trigger the result defined by the following
// Then helper
func (mmGetOrdersByUserId *mRepositoryMockGetOrdersByUserId) When(ctx context.Context, i1 int) *RepositoryMockGetOrdersByUserIdExpectation {
	if mmGetOrdersByUserId.mock.funcGetOrdersByUserId != nil {
		mmGetOrdersByUserId.mock.t.Fatalf("RepositoryMock.GetOrdersByUserId mock is already set by Set")
	}

	expectation := &RepositoryMockGetOrdersByUserIdExpectation{
		mock:   mmGetOrdersByUserId.mock,
		params: &RepositoryMockGetOrdersByUserIdParams{ctx, i1},
	}
	mmGetOrdersByUserId.expectations = append(mmGetOrdersByUserId.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetOrdersByUserId return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetOrdersByUserIdExpectation) Then(opa1 []*models.Order, err error) *RepositoryMock {
	e.results = &RepositoryMockGetOrdersByUserIdResults{opa1, err}
	return e.mock
}

// GetOrdersByUserId implements Repository
func (mmGetOrdersByUserId *RepositoryMock) GetOrdersByUserId(ctx context.Context, i1 int) (opa1 []*models.Order, err error) {
	mm_atomic.AddUint64(&mmGetOrdersByUserId.beforeGetOrdersByUserIdCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrdersByUserId.afterGetOrdersByUserIdCounter, 1)

	if mmGetOrdersByUserId.inspectFuncGetOrdersByUserId != nil {
		mmGetOrdersByUserId.inspectFuncGetOrdersByUserId(ctx, i1)
	}

	mm_params := &RepositoryMockGetOrdersByUserIdParams{ctx, i1}

	// Record call args
	mmGetOrdersByUserId.GetOrdersByUserIdMock.mutex.Lock()
	mmGetOrdersByUserId.GetOrdersByUserIdMock.callArgs = append(mmGetOrdersByUserId.GetOrdersByUserIdMock.callArgs, mm_params)
	mmGetOrdersByUserId.GetOrdersByUserIdMock.mutex.Unlock()

	for _, e := range mmGetOrdersByUserId.GetOrdersByUserIdMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.opa1, e.results.err
		}
	}

	if mmGetOrdersByUserId.GetOrdersByUserIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrdersByUserId.GetOrdersByUserIdMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrdersByUserId.GetOrdersByUserIdMock.defaultExpectation.params
		mm_got := RepositoryMockGetOrdersByUserIdParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrdersByUserId.t.Errorf("RepositoryMock.GetOrdersByUserId got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrdersByUserId.GetOrdersByUserIdMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrdersByUserId.t.Fatal("No results are set for the RepositoryMock.GetOrdersByUserId")
		}
		return (*mm_results).opa1, (*mm_results).err
	}
	if mmGetOrdersByUserId.funcGetOrdersByUserId != nil {
		return mmGetOrdersByUserId.funcGetOrdersByUserId(ctx, i1)
	}
	mmGetOrdersByUserId.t.Fatalf("Unexpected call to RepositoryMock.GetOrdersByUserId. %v %v", ctx, i1)
	return
}

// GetOrdersByUserIdAfterCounter returns a count of finished RepositoryMock.GetOrdersByUserId invocations
func (mmGetOrdersByUserId *RepositoryMock) GetOrdersByUserIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrdersByUserId.afterGetOrdersByUserIdCounter)
}

// GetOrdersByUserIdBeforeCounter returns a count of RepositoryMock.GetOrdersByUserId invocations
func (mmGetOrdersByUserId *RepositoryMock) GetOrdersByUserIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrdersByUserId.beforeGetOrdersByUserIdCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetOrdersByUserId.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrdersByUserId *mRepositoryMockGetOrdersByUserId) Calls() []*RepositoryMockGetOrdersByUserIdParams {
	mmGetOrdersByUserId.mutex.RLock()

	argCopy := make([]*RepositoryMockGetOrdersByUserIdParams, len(mmGetOrdersByUserId.callArgs))
	copy(argCopy, mmGetOrdersByUserId.callArgs)

	mmGetOrdersByUserId.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrdersByUserIdDone returns true if the count of the GetOrdersByUserId invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetOrdersByUserIdDone() bool {
	for _, e := range m.GetOrdersByUserIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrdersByUserIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrdersByUserIdCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrdersByUserId != nil && mm_atomic.LoadUint64(&m.afterGetOrdersByUserIdCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOrdersByUserIdInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetOrdersByUserIdInspect() {
	for _, e := range m.GetOrdersByUserIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetOrdersByUserId with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrdersByUserIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrdersByUserIdCounter) < 1 {
		if m.GetOrdersByUserIdMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetOrdersByUserId")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetOrdersByUserId with params: %#v", *m.GetOrdersByUserIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrdersByUserId != nil && mm_atomic.LoadUint64(&m.afterGetOrdersByUserIdCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetOrdersByUserId")
	}
}

type mRepositoryMockReadOrder struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockReadOrderExpectation
	expectations       []*RepositoryMockReadOrderExpectation

	callArgs []*RepositoryMockReadOrderParams
	mutex    sync.RWMutex
}

// RepositoryMockReadOrderExpectation specifies expectation struct of the Repository.ReadOrder
type RepositoryMockReadOrderExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockReadOrderParams
	results *RepositoryMockReadOrderResults
	Counter uint64
}

// RepositoryMockReadOrderParams contains parameters of the Repository.ReadOrder
type RepositoryMockReadOrderParams struct {
	ctx context.Context
	i1  int
}

// RepositoryMockReadOrderResults contains results of the Repository.ReadOrder
type RepositoryMockReadOrderResults struct {
	op1 *models.Order
	err error
}

// Expect sets up expected params for Repository.ReadOrder
func (mmReadOrder *mRepositoryMockReadOrder) Expect(ctx context.Context, i1 int) *mRepositoryMockReadOrder {
	if mmReadOrder.mock.funcReadOrder != nil {
		mmReadOrder.mock.t.Fatalf("RepositoryMock.ReadOrder mock is already set by Set")
	}

	if mmReadOrder.defaultExpectation == nil {
		mmReadOrder.defaultExpectation = &RepositoryMockReadOrderExpectation{}
	}

	mmReadOrder.defaultExpectation.params = &RepositoryMockReadOrderParams{ctx, i1}
	for _, e := range mmReadOrder.expectations {
		if minimock.Equal(e.params, mmReadOrder.defaultExpectation.params) {
			mmReadOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadOrder.defaultExpectation.params)
		}
	}

	return mmReadOrder
}

// Inspect accepts an inspector function that has same arguments as the Repository.ReadOrder
func (mmReadOrder *mRepositoryMockReadOrder) Inspect(f func(ctx context.Context, i1 int)) *mRepositoryMockReadOrder {
	if mmReadOrder.mock.inspectFuncReadOrder != nil {
		mmReadOrder.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ReadOrder")
	}

	mmReadOrder.mock.inspectFuncReadOrder = f

	return mmReadOrder
}

// Return sets up results that will be returned by Repository.ReadOrder
func (mmReadOrder *mRepositoryMockReadOrder) Return(op1 *models.Order, err error) *RepositoryMock {
	if mmReadOrder.mock.funcReadOrder != nil {
		mmReadOrder.mock.t.Fatalf("RepositoryMock.ReadOrder mock is already set by Set")
	}

	if mmReadOrder.defaultExpectation == nil {
		mmReadOrder.defaultExpectation = &RepositoryMockReadOrderExpectation{mock: mmReadOrder.mock}
	}
	mmReadOrder.defaultExpectation.results = &RepositoryMockReadOrderResults{op1, err}
	return mmReadOrder.mock
}

//Set uses given function f to mock the Repository.ReadOrder method
func (mmReadOrder *mRepositoryMockReadOrder) Set(f func(ctx context.Context, i1 int) (op1 *models.Order, err error)) *RepositoryMock {
	if mmReadOrder.defaultExpectation != nil {
		mmReadOrder.mock.t.Fatalf("Default expectation is already set for the Repository.ReadOrder method")
	}

	if len(mmReadOrder.expectations) > 0 {
		mmReadOrder.mock.t.Fatalf("Some expectations are already set for the Repository.ReadOrder method")
	}

	mmReadOrder.mock.funcReadOrder = f
	return mmReadOrder.mock
}

// When sets expectation for the Repository.ReadOrder which will trigger the result defined by the following
// Then helper
func (mmReadOrder *mRepositoryMockReadOrder) When(ctx context.Context, i1 int) *RepositoryMockReadOrderExpectation {
	if mmReadOrder.mock.funcReadOrder != nil {
		mmReadOrder.mock.t.Fatalf("RepositoryMock.ReadOrder mock is already set by Set")
	}

	expectation := &RepositoryMockReadOrderExpectation{
		mock:   mmReadOrder.mock,
		params: &RepositoryMockReadOrderParams{ctx, i1},
	}
	mmReadOrder.expectations = append(mmReadOrder.expectations, expectation)
	return expectation
}

// Then sets up Repository.ReadOrder return parameters for the expectation previously defined by the When method
func (e *RepositoryMockReadOrderExpectation) Then(op1 *models.Order, err error) *RepositoryMock {
	e.results = &RepositoryMockReadOrderResults{op1, err}
	return e.mock
}

// ReadOrder implements Repository
func (mmReadOrder *RepositoryMock) ReadOrder(ctx context.Context, i1 int) (op1 *models.Order, err error) {
	mm_atomic.AddUint64(&mmReadOrder.beforeReadOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmReadOrder.afterReadOrderCounter, 1)

	if mmReadOrder.inspectFuncReadOrder != nil {
		mmReadOrder.inspectFuncReadOrder(ctx, i1)
	}

	mm_params := &RepositoryMockReadOrderParams{ctx, i1}

	// Record call args
	mmReadOrder.ReadOrderMock.mutex.Lock()
	mmReadOrder.ReadOrderMock.callArgs = append(mmReadOrder.ReadOrderMock.callArgs, mm_params)
	mmReadOrder.ReadOrderMock.mutex.Unlock()

	for _, e := range mmReadOrder.ReadOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmReadOrder.ReadOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadOrder.ReadOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmReadOrder.ReadOrderMock.defaultExpectation.params
		mm_got := RepositoryMockReadOrderParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadOrder.t.Errorf("RepositoryMock.ReadOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadOrder.ReadOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmReadOrder.t.Fatal("No results are set for the RepositoryMock.ReadOrder")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmReadOrder.funcReadOrder != nil {
		return mmReadOrder.funcReadOrder(ctx, i1)
	}
	mmReadOrder.t.Fatalf("Unexpected call to RepositoryMock.ReadOrder. %v %v", ctx, i1)
	return
}

// ReadOrderAfterCounter returns a count of finished RepositoryMock.ReadOrder invocations
func (mmReadOrder *RepositoryMock) ReadOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadOrder.afterReadOrderCounter)
}

// ReadOrderBeforeCounter returns a count of RepositoryMock.ReadOrder invocations
func (mmReadOrder *RepositoryMock) ReadOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadOrder.beforeReadOrderCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ReadOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadOrder *mRepositoryMockReadOrder) Calls() []*RepositoryMockReadOrderParams {
	mmReadOrder.mutex.RLock()

	argCopy := make([]*RepositoryMockReadOrderParams, len(mmReadOrder.callArgs))
	copy(argCopy, mmReadOrder.callArgs)

	mmReadOrder.mutex.RUnlock()

	return argCopy
}

// MinimockReadOrderDone returns true if the count of the ReadOrder invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockReadOrderDone() bool {
	for _, e := range m.ReadOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadOrder != nil && mm_atomic.LoadUint64(&m.afterReadOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadOrderInspect logs each unmet expectation
func (m *RepositoryMock) MinimockReadOrderInspect() {
	for _, e := range m.ReadOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ReadOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadOrderCounter) < 1 {
		if m.ReadOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ReadOrder")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ReadOrder with params: %#v", *m.ReadOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadOrder != nil && mm_atomic.LoadUint64(&m.afterReadOrderCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.ReadOrder")
	}
}

type mRepositoryMockUpdateOrder struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateOrderExpectation
	expectations       []*RepositoryMockUpdateOrderExpectation

	callArgs []*RepositoryMockUpdateOrderParams
	mutex    sync.RWMutex
}

// RepositoryMockUpdateOrderExpectation specifies expectation struct of the Repository.UpdateOrder
type RepositoryMockUpdateOrderExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockUpdateOrderParams
	results *RepositoryMockUpdateOrderResults
	Counter uint64
}

// RepositoryMockUpdateOrderParams contains parameters of the Repository.UpdateOrder
type RepositoryMockUpdateOrderParams struct {
	ctx context.Context
	i1  int
	i2  int
}

// RepositoryMockUpdateOrderResults contains results of the Repository.UpdateOrder
type RepositoryMockUpdateOrderResults struct {
	err error
}

// Expect sets up expected params for Repository.UpdateOrder
func (mmUpdateOrder *mRepositoryMockUpdateOrder) Expect(ctx context.Context, i1 int, i2 int) *mRepositoryMockUpdateOrder {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("RepositoryMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &RepositoryMockUpdateOrderExpectation{}
	}

	mmUpdateOrder.defaultExpectation.params = &RepositoryMockUpdateOrderParams{ctx, i1, i2}
	for _, e := range mmUpdateOrder.expectations {
		if minimock.Equal(e.params, mmUpdateOrder.defaultExpectation.params) {
			mmUpdateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrder.defaultExpectation.params)
		}
	}

	return mmUpdateOrder
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateOrder
func (mmUpdateOrder *mRepositoryMockUpdateOrder) Inspect(f func(ctx context.Context, i1 int, i2 int)) *mRepositoryMockUpdateOrder {
	if mmUpdateOrder.mock.inspectFuncUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateOrder")
	}

	mmUpdateOrder.mock.inspectFuncUpdateOrder = f

	return mmUpdateOrder
}

// Return sets up results that will be returned by Repository.UpdateOrder
func (mmUpdateOrder *mRepositoryMockUpdateOrder) Return(err error) *RepositoryMock {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("RepositoryMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &RepositoryMockUpdateOrderExpectation{mock: mmUpdateOrder.mock}
	}
	mmUpdateOrder.defaultExpectation.results = &RepositoryMockUpdateOrderResults{err}
	return mmUpdateOrder.mock
}

//Set uses given function f to mock the Repository.UpdateOrder method
func (mmUpdateOrder *mRepositoryMockUpdateOrder) Set(f func(ctx context.Context, i1 int, i2 int) (err error)) *RepositoryMock {
	if mmUpdateOrder.defaultExpectation != nil {
		mmUpdateOrder.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateOrder method")
	}

	if len(mmUpdateOrder.expectations) > 0 {
		mmUpdateOrder.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateOrder method")
	}

	mmUpdateOrder.mock.funcUpdateOrder = f
	return mmUpdateOrder.mock
}

// When sets expectation for the Repository.UpdateOrder which will trigger the result defined by the following
// Then helper
func (mmUpdateOrder *mRepositoryMockUpdateOrder) When(ctx context.Context, i1 int, i2 int) *RepositoryMockUpdateOrderExpectation {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("RepositoryMock.UpdateOrder mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateOrderExpectation{
		mock:   mmUpdateOrder.mock,
		params: &RepositoryMockUpdateOrderParams{ctx, i1, i2},
	}
	mmUpdateOrder.expectations = append(mmUpdateOrder.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateOrder return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateOrderExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateOrderResults{err}
	return e.mock
}

// UpdateOrder implements Repository
func (mmUpdateOrder *RepositoryMock) UpdateOrder(ctx context.Context, i1 int, i2 int) (err error) {
	mm_atomic.AddUint64(&mmUpdateOrder.beforeUpdateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrder.afterUpdateOrderCounter, 1)

	if mmUpdateOrder.inspectFuncUpdateOrder != nil {
		mmUpdateOrder.inspectFuncUpdateOrder(ctx, i1, i2)
	}

	mm_params := &RepositoryMockUpdateOrderParams{ctx, i1, i2}

	// Record call args
	mmUpdateOrder.UpdateOrderMock.mutex.Lock()
	mmUpdateOrder.UpdateOrderMock.callArgs = append(mmUpdateOrder.UpdateOrderMock.callArgs, mm_params)
	mmUpdateOrder.UpdateOrderMock.mutex.Unlock()

	for _, e := range mmUpdateOrder.UpdateOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateOrder.UpdateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrder.UpdateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrder.UpdateOrderMock.defaultExpectation.params
		mm_got := RepositoryMockUpdateOrderParams{ctx, i1, i2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrder.t.Errorf("RepositoryMock.UpdateOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrder.UpdateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOrder.t.Fatal("No results are set for the RepositoryMock.UpdateOrder")
		}
		return (*mm_results).err
	}
	if mmUpdateOrder.funcUpdateOrder != nil {
		return mmUpdateOrder.funcUpdateOrder(ctx, i1, i2)
	}
	mmUpdateOrder.t.Fatalf("Unexpected call to RepositoryMock.UpdateOrder. %v %v %v", ctx, i1, i2)
	return
}

// UpdateOrderAfterCounter returns a count of finished RepositoryMock.UpdateOrder invocations
func (mmUpdateOrder *RepositoryMock) UpdateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrder.afterUpdateOrderCounter)
}

// UpdateOrderBeforeCounter returns a count of RepositoryMock.UpdateOrder invocations
func (mmUpdateOrder *RepositoryMock) UpdateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrder.beforeUpdateOrderCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrder *mRepositoryMockUpdateOrder) Calls() []*RepositoryMockUpdateOrderParams {
	mmUpdateOrder.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateOrderParams, len(mmUpdateOrder.callArgs))
	copy(argCopy, mmUpdateOrder.callArgs)

	mmUpdateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrderDone returns true if the count of the UpdateOrder invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateOrderDone() bool {
	for _, e := range m.UpdateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrder != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateOrderInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateOrderInspect() {
	for _, e := range m.UpdateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderCounter) < 1 {
		if m.UpdateOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdateOrder")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateOrder with params: %#v", *m.UpdateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrder != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdateOrder")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateOrderInspect()

		m.MinimockDeleteOrderInspect()

		m.MinimockGetOrdersByUserIdInspect()

		m.MinimockReadOrderInspect()

		m.MinimockUpdateOrderInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateOrderDone() &&
		m.MinimockDeleteOrderDone() &&
		m.MinimockGetOrdersByUserIdDone() &&
		m.MinimockReadOrderDone() &&
		m.MinimockUpdateOrderDone()
}
